#!/usr/bin/env python3
# main_multi_dataset.py - YOLO11 Hierarchical Multi-Dataset Training Framework

import os
import sys
from pathlib import Path
import shutil
from datetime import datetime
import json

# Import framework components
from setup_utils import check_gpu, install_required_packages
from hyperparameters import create_hyperparameters_file, load_hyperparameters
from memory_utils import show_memory_usage, clean_memory
from training import train_model, save_to_drive
from model_downloader import download_yolo11_models, download_specific_model_type
from language_manager import get_text, select_language

# Import updated multi-dataset manager
try:
    from multi_dataset_manager import YAMLBasedMultiDatasetManager
except ImportError:
    print("‚ö†Ô∏è  YAMLBasedMultiDatasetManager not found, trying legacy import...")
    from multi_dataset_manager import MultiDatasetManager as YAMLBasedMultiDatasetManager

# Import hierarchical detection utils
try:
    from hierarchical_detection_utils import HierarchicalDetectionVisualizer
    HIERARCHICAL_DETECTION_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  HierarchicalDetectionVisualizer not available")
    HIERARCHICAL_DETECTION_AVAILABLE = False

# Import augmentation systems
try:
    from tomato_disease_augmentation import TomatoDiseaseAugmentation
    from tomato_pest_augmentation import TomatoPestAugmentation
    AUGMENTATION_SYSTEMS_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  Augmentation systems not available")
    AUGMENTATION_SYSTEMS_AVAILABLE = False

# Check if running in Colab
def is_colab():
    """Check if running in Google Colab"""
    try:
        import google.colab
        print("‚úÖ Google Colab environment detected.")
        return True
    except:
        print("üíª Running in local environment.")
        return False

def get_tarim_drive_paths():
    """Google Drive'da 'Tarƒ±m' taban klas√∂r√ºn√º ve alt klas√∂rlerini bul/olu≈ütur.
    D√∂n√º≈ü: {
      'base': '/content/drive/MyDrive/Tarƒ±m',
      'colab_egitim': '/content/drive/MyDrive/Tarim/colab_egitim',
      'yolo11_models': '/content/drive/MyDrive/Tarim/colab_egitim/yolo11_models'
    }
    """
    if not is_colab():
        return None
    # Drive mount kontrol√º
    if not os.path.exists('/content/drive'):
        if not mount_google_drive():
            return None
    mydrive = "/content/drive/MyDrive"
    # T√ºrk√ße 'Tarƒ±m' varsa onu kullan, yoksa 'Tarim' ya da olu≈ütur
    tarim_candidates = [os.path.join(mydrive, 'Tarƒ±m'), os.path.join(mydrive, 'Tarim')]
    base = None
    for c in tarim_candidates:
        if os.path.exists(c):
            base = c
            break
    if base is None:
        # √ñnce T√ºrk√ße karakterli klas√∂r√º olu≈üturmayƒ± dene
        base = tarim_candidates[0]
        try:
            os.makedirs(base, exist_ok=True)
        except Exception:
            base = tarim_candidates[1]
            os.makedirs(base, exist_ok=True)
    colab_egitim = os.path.join(base, 'colab_egitim')
    yolo11_models = os.path.join(base, 'yolo11_models')
    os.makedirs(colab_egitim, exist_ok=True)
    os.makedirs(yolo11_models, exist_ok=True)
    return {'base': base, 'colab_egitim': colab_egitim, 'yolo11_models': yolo11_models}

def get_smartfarm_models_dir():
    """Colab i√ßin model klas√∂r√ºn√º '/content/drive/MyDrive/SmartFarm/colab_learn/yolo11_models' olarak d√∂nd√ºr√ºr ve yoksa olu≈üturur."""
    if not is_colab():
        return None
    if not os.path.exists('/content/drive'):
        if not mount_google_drive():
            return None
    path = "/content/drive/MyDrive/SmartFarm/colab_learn/yolo11_models"
    os.makedirs(path, exist_ok=True)
    return path

def mount_google_drive():
    """Mount Google Drive"""
    try:
        from google.colab import drive
        drive.mount('/content/drive')
        print("‚úÖ Google Drive mounted successfully.")
        return True
    except Exception as e:
        print(f"‚ùå Error mounting Google Drive: {e}")
        return False

def save_models_to_drive(drive_folder_path, best_file=True, last_file=True):
    """Save best and last model files to Google Drive"""
    if not is_colab():
        print("‚ÑπÔ∏è  This function only works in Google Colab.")
        return False
    
    # Check if Google Drive is mounted
    if not os.path.exists('/content/drive'):
        if not mount_google_drive():
            return False
    
    # Check source directory
    source_dir = "runs/train/exp/weights"
    if not os.path.exists(source_dir):
        print(f"‚ùå Source directory not found: {source_dir}")
        return False
    
    # Create target directory
    os.makedirs(drive_folder_path, exist_ok=True)
    
    # Copy files
    copied_files = []
    
    if best_file and os.path.exists(os.path.join(source_dir, "best.pt")):
        shutil.copy2(os.path.join(source_dir, "best.pt"), os.path.join(drive_folder_path, "best.pt"))
        copied_files.append("best.pt")
    
    if last_file and os.path.exists(os.path.join(source_dir, "last.pt")):
        shutil.copy2(os.path.join(source_dir, "last.pt"), os.path.join(drive_folder_path, "last.pt"))
        copied_files.append("last.pt")
    
    # Copy additional files
    additional_files = ["merged_dataset.yaml", "unified_class_mapping.json", "analysis_report.json"]
    for file_name in additional_files:
        if os.path.exists(file_name):
            shutil.copy2(file_name, os.path.join(drive_folder_path, file_name))
            copied_files.append(file_name)
    
    if copied_files:
        print(f"‚úÖ Files saved to Google Drive: {', '.join(copied_files)}")
        print(f"üìÅ Save location: {drive_folder_path}")
        print(f"üìÇ Dosyalar ≈üu klas√∂rde: {drive_folder_path}")
        print(f"üóÇÔ∏è  Kaydedilen dosya sayƒ±sƒ±: {len(copied_files)}")
        return True
    else:
        print("‚ùå No files found to copy.")
        return False

def download_models_menu():
    """Interactive menu for downloading YOLO11 models"""
    print(f"\n{get_text('model_download_title')}")
    
    if is_colab():
        default_dir = get_smartfarm_models_dir() or "/content/colab_learn/yolo11_models"
    else:
        default_dir = "yolo11_models"
    save_dir = input(get_text('save_directory', default=default_dir)) or default_dir
    
    print(f"\n{get_text('download_options')}")
    print(get_text('single_model'))
    print(get_text('all_detection'))
    print(get_text('all_models'))
    
    choice = input(f"\n{get_text('your_choice')}")
    
    if choice == "1":
        print(f"\n{get_text('select_model_type')}")
        print(get_text('detection_default'))
        print(get_text('segmentation'))
        print(get_text('classification'))
        print(get_text('pose'))
        print(get_text('obb'))
        
        model_type_map = {
            "1": "detection",
            "2": "segmentation", 
            "3": "classification",
            "4": "pose",
            "5": "obb"
        }
        
        model_type_choice = input(get_text('enter_choice_1_5')) or "1"
        model_type = model_type_map.get(model_type_choice, "detection")
        
        print(f"\n{get_text('select_model_size')}")
        print(get_text('small'))
        print(get_text('medium_default'))
        print(get_text('large'))
        print(get_text('extra_large'))
        
        size_map = {
            "1": "s",
            "2": "m",
            "3": "l",
            "4": "x"
        }
        
        size_choice = input(get_text('enter_choice_1_4')) or "2"
        size = size_map.get(size_choice, "m")
        
        model_path = download_specific_model_type(model_type, size, save_dir)
        if model_path:
            print(f"\n‚úÖ Model ba≈üarƒ±yla indirildi: {model_path}")
    
    elif choice == "2":
        detection_models = ["yolo11s.pt", "yolo11m.pt", "yolo11l.pt", "yolo11x.pt"]
        downloaded = download_yolo11_models(save_dir, detection_models)
        print(f"\n‚úÖ {len(downloaded)} tespit modeli indirildi: {save_dir}")
    
    elif choice == "3":
        downloaded = download_yolo11_models(save_dir)
        print(f"\n‚úÖ {len(downloaded)} model indirildi: {save_dir}")
    
    else:
        print("\n‚ùå Ge√ßersiz se√ßim. Hi√ßbir model indirilmedi.")
        return None
    
    return save_dir

def hierarchical_dataset_setup():
    """Setup for hierarchical multi-dataset training"""
    print("\n===== Hiyerar≈üik √áoklu Veri Seti Kurulumu =====")
    
    # Initialize the YAML-based dataset manager
    config_file = input("Konfig√ºrasyon dosyasƒ± yolu (varsayƒ±lan: config_datasets.yaml): ") or "config_datasets.yaml"
    
    if not os.path.exists(config_file):
        print(f"‚ùå Konfig√ºrasyon dosyasƒ± bulunamadƒ±: {config_file}")
        print("L√ºtfen config_datasets.yaml dosyasƒ±nƒ±n mevcut dizinde olduƒüundan emin olun")
        return None
    
    manager = YAMLBasedMultiDatasetManager(config_file=config_file)
    
    # Show system information
    print(f"\nüìä Sistem Bilgileri:")
    print(f"‚úÖ Konfig√ºrasyon y√ºklendi: {config_file}")
    print(f"üìÅ Mevcut gruplar: {len(manager.get_available_dataset_groups())}")
    
    # Interactive dataset selection
    selected_group = manager.interactive_dataset_selection()
    
    if not selected_group:
        print("‚ùå Hi√ßbir veri seti grubu se√ßilmedi")
        return None
    
    # Get recommendations
    recommendations = manager.get_training_recommendations(selected_group)
    
    print(f"\nüéØ '{selected_group}' i√ßin Eƒüitim √ñnerileri:")
    for key, value in recommendations.items():
        if isinstance(value, list):
            print(f"  {key}:")
            for item in value:
                print(f"    ‚Ä¢ {item}")
        else:
            print(f"  {key}: {value}")
    
    # Get global settings
    settings = manager.get_global_settings()
    
    # Ask for target count per class (global default + opsiyonel sƒ±nƒ±f bazlƒ± hedefler)
    default_target = settings.get('default_target_count_per_class', 5000)
    while True:
        try:
            target_count = int(input(f"\nSƒ±nƒ±f ba≈üƒ±na hedef √∂rnek sayƒ±sƒ± (varsayƒ±lan: {default_target}): ") or str(default_target))
            if target_count > 0:
                break
            print("‚ùå L√ºtfen pozitif bir sayƒ± girin.")
        except ValueError:
            print("‚ùå L√ºtfen ge√ßerli bir sayƒ± girin.")

    # Opsiyonel: Kullanƒ±cƒ± sƒ±nƒ±f bazƒ±nda √∂zel hedef sayƒ±larƒ± girmek isterse
    per_class_targets = None
    customize = (input("\nSƒ±nƒ±f bazƒ±nda hedef sayƒ±larƒ± √∂zelle≈ütirmek ister misiniz? (e/h, varsayƒ±lan: h): ") or "h").lower()
    if customize.startswith('e'):
        per_class_targets = {}
        print("\nSƒ±nƒ±f bazlƒ± hedefler (bo≈ü bƒ±rakƒ±lƒ±rsa genel varsayƒ±lan kullanƒ±lacak):")
        for cls in manager.hierarchical_classes.keys():
            try:
                val = input(f"  ‚Ä¢ {cls} i√ßin hedef (varsayƒ±lan {target_count}): ")
                if val.strip() == "":
                    continue
                n = int(val)
                if n > 0:
                    per_class_targets[cls] = n
            except Exception:
                pass
    
    # Output directory
    default_output = "datasets/hierarchical_merged"
    output_dir = input(f"\nBirle≈ütirilmi≈ü veri seti dizini (varsayƒ±lan: {default_output}): ") or default_output
    
    return {
        'manager': manager,
        'selected_group': selected_group,
        'target_count': target_count,
        'per_class_targets': per_class_targets,
        'output_dir': output_dir,
        'recommendations': recommendations,
        'settings': settings
    }

def process_hierarchical_datasets(dataset_config):
    """Process hierarchical multi-datasets"""
    print("\n===== Hiyerar≈üik √áoklu Veri Setleri ƒ∞≈üleniyor =====")
    
    manager = dataset_config['manager']
    target_count = dataset_config['target_count']
    
    try:
        # 1. Download datasets
        print("\n1Ô∏è‚É£ Veri setleri indiriliyor...")
        download_success = manager.download_all_datasets()
        
        if not download_success:
            print("‚ùå Veri seti indirme ba≈üarƒ±sƒ±z!")
            return False
        
        # 2. Create unified class mapping
        print("\n2Ô∏è‚É£ Hiyerar≈üik sƒ±nƒ±f haritalamasƒ± olu≈üturuluyor...")
        classes_created = manager.create_unified_class_mapping()
        
        if classes_created == 0:
            print("‚ùå Hi√ßbir sƒ±nƒ±f haritalandƒ±rƒ±lamadƒ±!")
            return False
        
        print(f"‚úÖ {classes_created} ana sƒ±nƒ±f olu≈üturuldu")
        
        # 3. Merge datasets with hierarchical structure
        print("\n3Ô∏è‚É£ Veri setleri hiyerar≈üik yapƒ±yla birle≈ütiriliyor...")
        # Fonksiyona 'setup' dict'i ge√ßirildiƒüi i√ßin doƒürudan buradan oku
        pct = dataset_config.get('per_class_targets')
        target_arg = pct if pct else target_count
        merged_counts = manager.merge_datasets(target_count_per_class=target_arg)
        
        if not merged_counts:
            print("‚ùå Veri seti birle≈ütirme ba≈üarƒ±sƒ±z!")
            return False
        
        print(f"\n‚úÖ Hiyerar≈üik √ßoklu veri seti i≈üleme tamamlandƒ±!")
        print(f"üìÅ Birle≈ütirilmi≈ü veri seti: {manager.output_dir}")
        print(f"üìÑ YAML dosyasƒ±: merged_dataset.yaml")
        print(f"üè∑Ô∏è  Sƒ±nƒ±f haritasƒ±: unified_class_mapping.json")
        
        # Display final statistics
        total_samples = sum(merged_counts.values())
        print(f"\nüìä Son Veri Seti ƒ∞statistikleri:")
        print(f"   Toplam √∂rnek: {total_samples:,}")
        print(f"   Ana sƒ±nƒ±flar: {len(merged_counts)}")
        print(f"   Sƒ±nƒ±f ba≈üƒ±na √∂rnek: {total_samples // len(merged_counts):,} (ortalama)")
        
        for class_name, count in merged_counts.items():
            print(f"   {class_name}: {count:,}")
        
        return True
        
    except Exception as e:
        print(f"\n‚ùå Hiyerar≈üik veri seti i≈üleme sƒ±rasƒ±nda hata: {e}")
        import traceback
        traceback.print_exc()
        return False

def interactive_training_setup():
    """Interactive training parameter setup for hierarchical model"""
    print("\n===== Hiyerar≈üik Model Eƒüitim Kurulumu =====")
    
    # Dataset type selection
    print("\nVeri seti konfig√ºrasyonu:")
    print("1) Hiyerar≈üik √ßoklu veri seti (√ñnerilen)")
    print("2) Tek Roboflow veri seti (Eski)")
    
    while True:
        dataset_choice = input("\nSe√ßenek [1-2] (varsayƒ±lan: 1): ") or "1"
        if dataset_choice in ["1", "2"]:
            break
        print("‚ùå L√ºtfen 1 veya 2 se√ßin.")
    
    dataset_config = {}
    
    if dataset_choice == "1":
        # Hierarchical multi-dataset
        dataset_setup = hierarchical_dataset_setup()
        if not dataset_setup:
            return None
        
        dataset_config = {
            'type': 'hierarchical_multi',
            'setup': dataset_setup,
            'data_yaml': 'merged_dataset.yaml'
        }
    else:
        # Single dataset (legacy)
        roboflow_url = input("\nRoboflow URL: ").strip()
        if not roboflow_url:
            print("‚ùå URL saƒülanmadƒ±")
            return None
        
        dataset_config = {
            'type': 'single',
            'url': roboflow_url,
            'data_yaml': 'dataset.yaml'
        }
    
    # Project category
    print("\nProje kategorisi:")
    print("1) Hiyerar≈üik Tarƒ±msal AI (√ñnerilen)")
    print("2) Hastalƒ±k Tespiti")
    print("3) Zararlƒ± Tespiti")
    print("4) Karma Tarƒ±msal")
    print("5) √ñzel")
    
    while True:
        category_choice = input("\nKategori se√ßin [1-5] (varsayƒ±lan: 1): ") or "1"
        category_options = {
            "1": "hierarchical_agricultural",
            "2": "diseases",
            "3": "pests", 
            "4": "mixed",
            "5": "custom"
        }
        
        if category_choice in category_options:
            category = category_options[category_choice]
            if category == "custom":
                category = input("√ñzel kategori adƒ± girin: ").strip() or "custom"
            break
        print("‚ùå L√ºtfen 1-5 arasƒ± se√ßin.")
    
    # Get training recommendations
    if dataset_config['type'] == 'hierarchical_multi':
        recommendations = dataset_config['setup']['recommendations']
        recommended_model = recommendations.get('model', 'yolo11l.pt')
        recommended_batch = recommendations.get('batch_size', 8)
        recommended_size = recommendations.get('image_size', 640)
        estimated_time = recommendations.get('estimated_time', 'Unknown')
        
        print(f"\nüéØ Hiyerar≈üik model i√ßin √∂neriler:")
        print(f"   Model: {recommended_model}")
        print(f"   Batch boyutu: {recommended_batch}")
        print(f"   G√∂r√ºnt√º boyutu: {recommended_size}")
        print(f"   Tahmini s√ºre: {estimated_time}")
        
        # Show special notes if available
        special_notes = recommendations.get('special_notes', [])
        if special_notes:
            print(f"   √ñzel hususlar:")
            for note in special_notes:
                print(f"     ‚Ä¢ {note}")
    
    # Training parameters
    while True:
        try:
            if dataset_config['type'] == 'hierarchical_multi':
                default_epochs = 1000  # Updated default for hierarchical model
                epochs = int(input(f"\nEpoch sayƒ±sƒ± [100-2000 √∂nerilen] (varsayƒ±lan: {default_epochs}): ") or str(default_epochs))
            else:
                default_epochs = 1000  # Updated default for single dataset model
                epochs = int(input(f"\nEpoch sayƒ±sƒ± [100-2000 √∂nerilen] (varsayƒ±lan: {default_epochs}): ") or str(default_epochs))
            
            if epochs > 0:
                break
            print("‚ùå L√ºtfen pozitif bir sayƒ± girin.")
        except ValueError:
            print("‚ùå L√ºtfen ge√ßerli bir sayƒ± girin.")
    
    # Model size selection
    print("\nModel boyutunu se√ßin:")
    print("1) yolo11s.pt - K√º√ß√ºk (en hƒ±zlƒ±, d√º≈ü√ºk doƒüruluk)")
    print("2) yolo11m.pt - Orta (dengeli)")
    print("3) yolo11l.pt - B√ºy√ºk (y√ºksek doƒüruluk, yava≈ü) [Hiyerar≈üik i√ßin √∂nerilen]")
    print("4) yolo11x.pt - √áok B√ºy√ºk (en y√ºksek doƒüruluk, en yava≈ü)")

    while True:
        if dataset_config['type'] == 'hierarchical_multi':
            model_choice = input("\nModel se√ßin [1-4] (varsayƒ±lan: 3): ") or "3"
        else:
            model_choice = input("\nModel se√ßin [1-4] (varsayƒ±lan: 3): ") or "3"
        
        model_options = {
            "1": "yolo11s.pt",
            "2": "yolo11m.pt",
            "3": "yolo11l.pt",
            "4": "yolo11x.pt"
        }
        
        if model_choice in model_options:
            model = model_options[model_choice]
            
            # Check if model exists locally/Drive
            if is_colab():
                model_dir = get_smartfarm_models_dir() or os.path.join("/content/colab_learn", "yolo11_models")
            else:
                model_dir = "yolo11_models"
            model_path = os.path.join(model_dir, model)
            
            if not os.path.exists(model_path):
                print(f"\n‚ö†Ô∏è  Model {model} yerel olarak bulunamadƒ±.")
                download_now = input("≈ûimdi indir? (e/h, varsayƒ±lan: e): ").lower() or "e"
                
                if download_now.startswith("e"):
                    os.makedirs(model_dir, exist_ok=True)
                    download_specific_model_type("detection", model[6], model_dir)
                else:
                    print(f"‚ÑπÔ∏è  Model eƒüitim sƒ±rasƒ±nda otomatik olarak indirilecek.")
            break
        print("‚ùå L√ºtfen 1-4 arasƒ± se√ßin.")
    
    # Batch size ve image size varsayƒ±lanlarƒ± (Colab i√ßin optimize)
    # √ñneri: batch_size=16, img_size=512 (RAM ve hƒ±z dengesi)
    default_batch = 16
    default_img_size = 512
    
    while True:
        try:
            batch_size = int(input(f"\nBatch boyutu (varsayƒ±lan: {default_batch}, d√º≈ü√ºk RAM i√ßin k√º√ß√ºk): ") or str(default_batch))
            if batch_size > 0:
                break
            print("‚ùå L√ºtfen pozitif bir sayƒ± girin.")
        except ValueError:
            print("‚ùå L√ºtfen ge√ßerli bir sayƒ± girin.")
    
    while True:
        try:
            img_size = int(input(f"\nG√∂r√ºnt√º boyutu (varsayƒ±lan: {default_img_size}, 32'nin katƒ± olmalƒ± ‚Ä¢ Colab i√ßin 512 √∂nerilir): ") or str(default_img_size))
            if img_size > 0 and img_size % 32 == 0:
                break
            print("‚ùå L√ºtfen 32'nin katƒ± olan pozitif bir sayƒ± girin.")
        except ValueError:
            print("‚ùå L√ºtfen ge√ßerli bir sayƒ± girin.")

    # Speed mode (optimize epoch time)
    speed_mode_input = (input("\nHƒ±z modu (cache=ram, workers=8, plots=False) a√ßƒ±lsƒ±n mƒ±? (e/h, varsayƒ±lan: e): ") or "e").lower()
    speed_mode = speed_mode_input.startswith('e')
    
    # Google Drive save settings
    drive_save_path = None
    if is_colab():
        print("\nGoogle Drive kaydetme ayarlarƒ±:")
        save_to_drive_opt = input("Eƒüitim sonu√ßlarƒ±nƒ± Google Drive'a kaydet? (e/h, varsayƒ±lan: e): ").lower() or "e"
        
        if save_to_drive_opt.startswith("e"):
            default_drive_path = get_smartfarm_models_dir() or "/content/drive/MyDrive/SmartFarm/colab_learn/yolo11_models"
            drive_save_path = input(f"Kaydetme dizini (varsayƒ±lan: {default_drive_path}): ") or default_drive_path
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            drive_save_path = os.path.join(drive_save_path, timestamp)
            print(f"üìÅ Modeller ≈üuraya kaydedilecek: {drive_save_path}")
            # Klas√∂rleri olu≈ütur
            os.makedirs(drive_save_path, exist_ok=True)
    
    # Hyperparameter file
    use_hyp = input("\nHiperparametre dosyasƒ± kullan (hyp.yaml)? (e/h, varsayƒ±lan: e): ").lower() or "e"
    use_hyp = use_hyp.startswith("e")
    
    # Device detection
    device = check_gpu()
    
    # Build options dictionary
    options = {
        'dataset_config': dataset_config,
        'epochs': epochs,
        'model': model,
        'batch': batch_size,
        'imgsz': img_size,
        'device': device,
        'workers': 2,
        'data': dataset_config['data_yaml'],
        'project': 'runs/train',
        'name': 'exp',
        'pretrained': True,
        'optimizer': 'auto',
        'verbose': True,
        'exist_ok': True,
        'use_hyp': use_hyp,
        'category': category,
        'drive_save_path': drive_save_path,
        'speed_mode': speed_mode
    }
    
    # Save interval prompt (Drive kullanƒ±lƒ±yorsa 10, deƒüilse 50 varsayƒ±lan)
    save_interval_default = 10 if drive_save_path else 50
    try:
        if drive_save_path:
            save_interval = int(input(f"Drive'a ka√ß epoch'ta bir kaydedilsin? (varsayƒ±lan: {save_interval_default}): ") or str(save_interval_default))
        else:
            save_interval = int(input(f"Modele ka√ß epoch'ta bir yerel kaydetme yapƒ±lsƒ±n? (varsayƒ±lan: {save_interval_default}): ") or str(save_interval_default))
    except ValueError:
        save_interval = save_interval_default
    options['save_interval'] = save_interval
    
    # Display selected parameters
    print("\n===== Se√ßilen Eƒüitim Parametreleri =====")
    print(f"Veri seti tipi: {dataset_config['type']}")
    if dataset_config['type'] == 'hierarchical_multi':
        setup = dataset_config['setup']
        print(f"Veri seti grubu: {setup['selected_group']}")
        print(f"Sƒ±nƒ±f ba≈üƒ±na hedef √∂rnek: {setup['target_count']:,}")
        print(f"√áƒ±ktƒ± dizini: {setup['output_dir']}")
    
    print(f"Model: {model}")
    print(f"Epoch: {epochs}")
    print(f"Batch boyutu: {batch_size}")
    print(f"G√∂r√ºnt√º boyutu: {img_size}")
    print(f"Cihaz: {device}")
    print(f"DataLoader workers: {options['workers']} (hafƒ±za i√ßin d√º≈ü√ºk)")
    print(f"Dataset cache varsayƒ±lanƒ±: {'ram' if speed_mode else 'disk'}")
    print(f"cuDNN benchmark: Enabled (training.py i√ßinde)")
    print(f"Hƒ±z modu: {'A√ßƒ±k' if speed_mode else 'Kapalƒ±'}")
    print(f"Kategori: {category}")
    if dataset_config['type'] == 'hierarchical_multi':
        pct = dataset_config['setup'].get('per_class_targets')
        if pct:
            print("Sƒ±nƒ±f bazlƒ± hedefler: (√∂zet)")
            shown = 0
            for k, v in pct.items():
                print(f"  ‚Ä¢ {k}: {v}")
                shown += 1
                if shown >= 10:
                    print("  ‚Ä¢ ... (daha fazla sƒ±nƒ±f var)")
                    break
    if drive_save_path:
        print(f"Drive'a kaydetme aralƒ±ƒüƒ±: {options['save_interval']} epoch")
    else:
        print(f"Yerel kaydetme aralƒ±ƒüƒ±: {options['save_interval']} epoch")
    
    if drive_save_path:
        print(f"Drive kaydetme yolu: {drive_save_path}")
        # Kaydedilecek dosyalarƒ± net belirt
        print(f"Kaydedilecek dosyalar:")
        print(f"  ‚Ä¢ best.pt  ‚Üí {os.path.join(drive_save_path, 'best.pt')}")
        print(f"  ‚Ä¢ last.pt  ‚Üí {os.path.join(drive_save_path, 'last.pt')}")
    
    confirm = (input("\nBu parametrelerle devam et? (e/h, varsayƒ±lan: e): ") or "e").lower()
    if confirm != 'e' and confirm != 'evet' and confirm != 'yes':
        print("‚ùå Kurulum iptal edildi.")
        return None
    
    return options

def main():
    """Main function - Hierarchical Multi-Dataset Training Framework"""
    # Language selection at startup
    select_language()
    
    print("\n" + "="*70)
    print(get_text('main_title'))
    print(get_text('main_subtitle'))
    print("="*70)
    
    print(f"\n{get_text('main_menu')}")
    print(get_text('option_download'))
    print(get_text('option_training'))
    print(get_text('option_test'))
    print(get_text('option_exit'))
    
    choice = input(f"\n{get_text('select_option')}")
    
    if choice == "1":
        download_models_menu()
        if get_text('language_choice').startswith('e'):
            train_now = input("\nEƒüitim kurulumuna ge√ß? (e/h, varsayƒ±lan: e): ").lower() or "e"
            if not train_now.startswith("e"):
                return
        else:
            train_now = input("\nProceed to training setup? (y/n, default: y): ").lower() or "y"
            if not train_now.startswith("y"):
                return
        choice = "2"  # Continue to training
        
    if choice == "2":
        in_colab = is_colab()
        
        # (Opsiyonel) Gerekli paketleri y√ºkleme
        # Not: Paket kurulumlarƒ±nƒ± genellikle colab_setup.py √ºzerinden y√∂netmeniz √∂nerilir.
        do_install = (input("\nGerekli paketleri ≈üimdi y√ºklemek ister misiniz? (e/h, varsayƒ±lan: h): ") or "h").lower()
        if do_install.startswith("e"):
            print("\nüì¶ Gerekli paketler y√ºkleniyor...")
            install_required_packages()
        else:
            print("\n‚è≠Ô∏è Paket y√ºkleme atlandƒ±. (colab_setup.py ile kurulumu yapabilirsiniz)")
        
        # Interactive setup - this will handle checkpoint checking
        options = interactive_training_setup()
        if options is None:
            return
        
        # Check if we're resuming from a checkpoint
        if options.get('resume'):
            print("\n" + "="*50)
            print(f"üîÑ Eƒüitime devam ediliyor: {options['checkpoint_path']}")
            print("="*50)
            
            # Skip dataset processing when resuming
            results = train_model(options, hyp=None, epochs=options['epochs'], 
                               drive_save_interval=options.get('save_interval', 10))
        else:
            # Process dataset(s) for new training
            dataset_config = options['dataset_config']
            
            if dataset_config['type'] == 'single':
                # Single dataset processing (legacy)
                from dataset_utils import download_dataset
                
                if not download_dataset(dataset_config['url']):
                    print('‚ùå Veri seti indirme ba≈üarƒ±sƒ±z. √áƒ±kƒ±lƒ±yor...')
                    return
                    
            elif dataset_config['type'] == 'hierarchical_multi':
                # Hierarchical multi-dataset processing
                if not process_hierarchical_datasets(dataset_config['setup']):
                    print('‚ùå Hiyerar≈üik veri seti i≈üleme ba≈üarƒ±sƒ±z. √áƒ±kƒ±lƒ±yor...')
                    return
            
            # Show memory status before training
            show_memory_usage("Eƒüitim √ñncesi")
            
            # Create hyperparameter file for new training
            from hyperparameters import create_hyperparameters_file, load_hyperparameters
            hyp_path = create_hyperparameters_file()
            hyperparameters = load_hyperparameters(hyp_path)
            
            # Start new training
            print(f"\nüöÄ Yeni model eƒüitimi ba≈ülatƒ±lƒ±yor...")
            results = train_model(options, hyp=hyperparameters, 
                               epochs=options['epochs'], 
                               drive_save_interval=options.get('save_interval', 10))
        
        if results:
            print('‚úÖ Eƒüitim ba≈üarƒ±yla tamamlandƒ±!')
            print(f'üìä Sonu√ßlar: {results}')
            
            # Initialize hierarchical detection if available
            if HIERARCHICAL_DETECTION_AVAILABLE:
                print(f"\nüéØ Hiyerar≈üik tespit sistemi ba≈ülatƒ±lƒ±yor...")
                try:
                    visualizer = HierarchicalDetectionVisualizer()
                    print(f"‚úÖ Hiyerar≈üik tespit sistemi hazƒ±r!")
                    print(f"üè∑Ô∏è  Tespit formatƒ±: 'ZARARLI: Kƒ±rmƒ±zƒ± √ñr√ºmcek (0.85)'")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Hiyerar≈üik tespit ba≈ülatƒ±lamadƒ±: {e}")
            
            # Save to Google Drive
            if in_colab and options.get('drive_save_path'):
                drive_path = options['drive_save_path']
                print(f"\nüíæ Modeller Google Drive'a kaydediliyor...")
                print(f"üìÅ Hedef klas√∂r: {drive_path}")
                if save_models_to_drive(drive_path):
                    print(f"‚úÖ Modeller ba≈üarƒ±yla kaydedildi: {drive_path}")
                    print(f"üìÇ Kaydedilen dosyalar ≈üu konumda: {drive_path}")
                else:
                    print("‚ùå Modeller Google Drive'a kaydedilemedi.")
        else:
            print('‚ùå Eƒüitim ba≈üarƒ±sƒ±z veya kesildi.')
            
            # Save partial results if available
            if in_colab and options.get('drive_save_path'):
                save_anyway = input("\nKƒ±smi eƒüitim sonu√ßlarƒ±nƒ± Google Drive'a kaydet? (e/h, varsayƒ±lan: e): ").lower() or "e"
                if save_anyway.startswith("e"):
                    drive_path = options['drive_save_path']
                    print(f"\nüíæ Kƒ±smi sonu√ßlar Google Drive'a kaydediliyor...")
                    print(f"üìÅ Hedef klas√∂r: {drive_path}")
                    if save_models_to_drive(drive_path):
                        print(f"‚úÖ Kƒ±smi sonu√ßlar kaydedildi: {drive_path}")
                        print(f"üìÇ Kaydedilen dosyalar ≈üu konumda: {drive_path}")
                    else:
                        print("‚ùå Kƒ±smi sonu√ßlar kaydedilemedi.")
        
        # Clean memory
        show_memory_usage("Eƒüitim Sonrasƒ±")
        clean_memory()
    
    elif choice == "3":
        # Test hierarchical detection
        if not HIERARCHICAL_DETECTION_AVAILABLE:
            print("‚ùå Hiyerar≈üik tespit ara√ßlarƒ± mevcut deƒüil.")
            return
        
        model_path = input("Eƒüitilmi≈ü model yolunu girin (√∂rn: runs/train/exp/weights/best.pt): ").strip()
        if not model_path or not os.path.exists(model_path):
            print("‚ùå Model dosyasƒ± bulunamadƒ±.")
            return
        
        test_image = input("Test g√∂r√ºnt√ºs√º yolunu girin: ").strip()
        if not test_image or not os.path.exists(test_image):
            print("‚ùå Test g√∂r√ºnt√ºs√º bulunamadƒ±.")
            return
        
        try:
            from ultralytics import YOLO
            import cv2
            
            # Load model and visualizer
            model = YOLO(model_path)
            visualizer = HierarchicalDetectionVisualizer()
            
            # Run detection
            print(f"üîç Hiyerar≈üik tespit √ßalƒ±≈ütƒ±rƒ±lƒ±yor...")
            image = cv2.imread(test_image)
            results = model(image)
            
            # Apply hierarchical visualization
            annotated_image = visualizer.process_yolo_results(image, results[0])
            
            # Save result
            output_path = "hierarchical_detection_result.jpg"
            cv2.imwrite(output_path, annotated_image)
            
            # Generate report
            detections = visualizer.get_detection_summary(results[0])
            report = visualizer.create_detection_report(detections)
            
            print(f"\n{report}")
            print(f"‚úÖ A√ßƒ±klamalƒ± g√∂r√ºnt√º kaydedildi: {output_path}")
            
        except Exception as e:
            print(f"‚ùå Hiyerar≈üik tespit testi sƒ±rasƒ±nda hata: {e}")
    
    elif choice == "4":
        print("üëã √áƒ±kƒ±lƒ±yor...")
    
    else:
        print("‚ùå Ge√ßersiz se√ßenek. √áƒ±kƒ±lƒ±yor...")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Kullanƒ±cƒ± tarafƒ±ndan kesildi. √áƒ±kƒ±lƒ±yor...")
    except Exception as e:
        print(f"\n‚ùå Bir hata olu≈ütu: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print("\n‚úÖ ƒ∞≈ülem tamamlandƒ±.")
